package taskThreads

import (
	"fmt"
	"time"
)

// 3. **Использование канала для передачи данных**
//     > Задача: Напишите функцию, которая создает горутину, отправляющую числа от 1 до 5 в канал, а затем в main извлекает их и складывает,
// 		результат выводит в консоль.
//     Вопрос: когда заканчивается чтение с канала? Что если не закрывать канал?
//     Канал лучше с буфером или без? В чём отличие?
//     Что будет если использовать select? Как реализовать?

func TaskThree() {

	// 1. Чтение с канала заканчивается когда канал при чтении возвращает nil, при условии что канал закрыт, инач если он открыт, то будет блокировка
	// 2. Если не закрыть канал -> блокировка до прихода писателя
	// 3. Без буфера идет последовательное выполнение, с буфером параллельное, скорость без буфера зависит он быстроты цикла читающего
	// 4. Select тут не особо то и нужен, если только не использовать контекст чтобы за определенное время выходить

	ch := make(chan int) // Если нужен буфер, то ch := make(chan int, 5)
	buf := make([]int, 0, 5)

	// Запуск горутины
	go gorutine(ch)

	// Вывод без select
	// for i := range ch {
	// 	buf = append(buf, i)
	// }

	// Вывод с select
	done := false
	for !done {
		select {
		case i, ok := <-ch:
			if !ok {
				done = true
				// Делаем break иначе сует непонятный ноль в конце
				break
			}
			buf = append(buf, i)
		case <-time.After(time.Second * 10):
			fmt.Println("Тайм‑аут, выходим из select.")
			done = true
		}
	}

	fmt.Println(buf)

}

func gorutine(ch chan int) {

	for i := 1; i <= 5; i++ {
		ch <- i
	}
	close(ch)
}
